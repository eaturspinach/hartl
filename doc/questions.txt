1) is the email regex good enough?  can't you have numbers in an email
addy?
2) i found that self.encrypted_password = encrypt(self.password) more
explicit and clear than self.encrypted_password = encrypt(password)
3) remember what "secure one-way hashing" is
4) why use User.new instead of User.create! in specs?
5) so i understand if someone gets a hold of the encrypted_password
hash, they can conduct a rainbow attack.  The way to circumvent this is
to create a salt which is a hash of the password and a UTC timestamp.
The salt is then hashed with the submitted hashed password which yields
the encrypted_password hash.  However, the salt must be stored in the
database.  If someone gets a hold of the salt hash, they can hash that
with the password they're guessing (rainbow attacked), and compare that
with the encrypted_password hash (provided they got access to that
too).5) so i understand if someone gets a hold of the encrypted_password
hash, they can conduct a rainbow attack.  The way to circumvent this is
to create a salt which is a hash of the password and a UTC timestamp.
The salt is then hashed with the submitted hashed password which yields
the encrypted_password hash.  However, the salt must be stored in the
database.  If someone gets a hold of the salt hash, they can hash that
with the password they're guessing (rainbow attacked), and compare that
with the encrypted_password hash (provided they got access to that
too).5) so i understand if someone gets a hold of the encrypted_password
hash, they can conduct a rainbow attack.  The way to circumvent this is
to create a salt which is a hash of the password and a UTC timestamp.
The salt is then hashed with the submitted hashed password which yields
the encrypted_password hash.  However, the salt must be stored in the
database.  If someone gets a hold of the salt hash, they can hash that
with the password they're guessing (rainbow attacked), and compare that
with the encrypted_password hash (provided they got access to that
too).5) so i understand if someone gets a hold of the encrypted_password
hash, they can conduct a rainbow attack.  The way to circumvent this is
to create a salt which is a hash of the password and a UTC timestamp.
The salt is then hashed with the submitted hashed password which yields
the encrypted_password hash.  However, the salt must be stored in the
database.  If someone gets a hold of the salt hash, they can hash that
with the password they're guessing (rainbow attacked), and compare that
with the encrypted_password hash (provided they got access to that
too).5) so i understand if someone gets a hold of the encrypted_password
hash, they can conduct a rainbow attack.  The way to circumvent this is
to create a salt which is a hash of the password and a UTC timestamp.
The salt is then hashed with the submitted hashed password which yields
the encrypted_password hash.  However, the salt must be stored in the
database.  If someone gets a hold of the salt hash, they can hash that
with the password they're guessing (rainbow attacked), and compare that
with the encrypted_password hash (provided they got access to that too).
